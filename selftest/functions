#!/bin/bash
#
# Support functions for testbus self tests
#

#exec 2>client.log

# The following variable(s) are considered tunables that can be overridden from
# the test script after sourcing this file.
TESTBUS_CLAIM_TIMEOUT=60

# By setting TESTBUS_SELFTEST_LOCALFILES=yes, you can tell the testbus self tests
# to use the uninstalled programs and files.
if test -n "$TESTBUS_SELFTEST_LOCALFILES"; then
	if test ! -x ./testbus-client; then
		echo "Cannot run selftest in localfiles mode - no testbus-client in local directory" >&2
		exit 1
	fi
	CLIENT=./testbus-client
	PROXY=./dbus-proxy

	if test -f etc/common.xml; then
		sed 's:<schema name=[^"]*/:<schema name="schema:g' etc/common.xml > etc/local.xml
		CONFIG="--config etc/local.xml"
	fi
else
	CLIENT=testbus-client
	PROXY=dbus-proxy
	CONFIG=
	DEBUG=
fi

if test -n "$TESTBUS_SELFTEST_DEBUG"; then
	DEBUG="--debug $TESTBUS_SELFTEST_DEBUG"
fi

# Anything below this line is not user serviceable. Hands off, please.
TESTBUS_GLOBAL_STATUS=SUCCESS
TESTBUS_GROUP_STATUS=SUCCESS

declare -a TESTBUS_NAME_STACK
declare -a TESTBUS_HANDLE_STACK
declare -a TESTBUS_TEMPDIR_STACK
declare -a TESTBUS_FAILED_LIST

declare -i TESTBUS_TEST_COUNT
declare -i TESTBUS_FAILED_COUNT

TESTGROUP_NAME=default
TESTBUS_TEST_COUNT=0
TESTBUS_FAILED_COUNT=0

function testbus_call {

	$CLIENT $CONFIG $DEBUG "$@"
}

function testbus_trace {

	echo "$@" >&2
}

function __testbus_make_name {

	myname=$1
	basename $myname| tr - _
}

function __testbus_testcase_name {

	if [ -n "$TESTCASE_NAME" ]; then
		echo $TESTCASE_NAME
	else
		let depth=${#TESTBUS_NAME_STACK[*]}
		if [ $depth -ne 0 ]; then
			echo ${TESTBUS_NAME_STACK[$depth-1]}
		fi
	fi
}

function __testbus_report {

	status=${1:-NOSTATUS}
	shift || true

	name=`__testbus_testcase_name`
	if [ -z "$name" ]; then
		name="default"
	fi
		
	{
		echo -n "### TESTRESULT $name: $status"
		if [ -n "$*" ]; then
			echo -n " ($*)"
		fi
		echo
	} >&2

	if [ "$status" != "SUCCESS" ]; then
		# FIXME: we should save a tarball of the failed test(s)
		TESTBUS_FAILED_LIST+=("$TESTCASE_NAME($status)")
		TESTBUS_FAILED_COUNT+=1
		TESTBUS_GLOBAL_STATUS=FAILED
	fi
}

function __testbus_begin {

	newname=`__testbus_make_name $1`; shift

	let depth=${#TESTBUS_NAME_STACK[*]}
	if [ $depth -eq 0 ]; then
		TESTCASE_NAME=$newname
		TESTCASE_HANDLE=`testbus_call create-test $newname`
		if [ $? -ne 0 ]; then
			testbus_exit_fail "Unable to create test handle for test $TESTCASE_NAME"
		fi
		TESTCASE_TEMPDIR=`mktemp -d /tmp/testbusXXXXXX`
	else
		let top=$depth-1
		TESTCASE_NAME="${TESTBUS_NAME_STACK[$top]}.$newname"
		TESTCASE_HANDLE=`testbus_call create-test --context ${TESTBUS_HANDLE_STACK[$top]} $newname`
		if [ $? -ne 0 ]; then
			testbus_exit_fail "Unable to create test handle for test $TESTCASE_NAME"
		fi
		TESTCASE_TEMPDIR=${TESTBUS_TEMPDIR_STACK[$top]}/$newname
		mkdir -p $TESTCASE_TEMPDIR
	fi

	echo "### TESTBEGIN $TESTCASE_NAME"
	testbus_call show-xml --raw > $TESTCASE_TEMPDIR/xml-tree-before
}

function __testbus_finish {

	if [ -n "$TESTCASE_TEMPDIR" ]; then
		rm -rf $TESTCASE_TEMPDIR
		unset TESTCASE_TEMPDIR
	fi

	if [ -n "$TESTCASE_HANDLE" ]; then
		testbus_call delete $TESTCASE_HANDLE
		unset TESTCASE_HANDLE
	fi

	if [ -n "$TESTCASE_NAME" ]; then
		unset TESTCASE_NAME
	fi

	let depth=${#TESTBUS_NAME_STACK[*]}
	if [ $depth -ne 0 ]; then
		let top=$depth-1
		TESTCASE_HANDLE=${TESTBUS_HANDLE_STACK[$top]}
		TESTCASE_TEMPDIR=${TESTBUS_TEMPDIR_STACK[$top]}
	fi
}

function __testbus_begin_group {

	__testbus_begin "$@"

	TESTBUS_NAME_STACK+=($TESTCASE_NAME)
	TESTBUS_HANDLE_STACK+=($TESTCASE_HANDLE)
	TESTBUS_TEMPDIR_STACK+=($TESTCASE_TEMPDIR)

	unset TESTCASE_NAME
}

function __testbus_group_finish {

	__testbus_finish

	let depth=${#TESTBUS_NAME_STACK[*]}
	if [ $depth -ne 0 ]; then
		let top=$depth-1
		TESTCASE_NAME=${TESTBUS_NAME_STACK[$top]}
		TESTCASE_HANDLE=${TESTBUS_HANDLE_STACK[$top]}
		TESTCASE_TEMPDIR=${TESTBUS_TEMPDIR_STACK[$top]}
		unset TESTBUS_NAME_STACK[$top]
		unset TESTBUS_HANDLE_STACK[$top]
		unset TESTBUS_TEMPDIR_STACK[$top]
	else
		unset TESTCASE_NAME
		unset TESTCASE_HANDLE
		unset TESTCASE_TEMPDIR
	fi
}

function testbus_group_begin {

	__testbus_begin_group "$@"
}

function testbus_group_finish {

	__testbus_report "$@"
	__testbus_group_finish
}

function testbus_finish_all_groups {

	testbus_group_finish "$@"
	while [ -n "$TESTCASE_NAME" ]; do
		testbus_group_finish "$@"
	done
}

function testbus_test_begin {

	testbus_test_finish SUCCESS
	__testbus_begin "$@"
}

function testbus_test_finish {

	if [ -n "$TESTCASE_NAME" ]; then
		__testbus_report "$@"
		__testbus_finish
	fi
	return 0
}

function testbus_test_failure {

	testbus_test_finish FAILED "$@"
}

function testbus_test_success {

	testbus_test_finish SUCCESS "$@"
}

function __testbus_assert_handle {

	if [ -z "$TESTCASE_HANDLE" ]; then
		echo "$1: cannot call this function outside a test" >&2
		exit 1
	fi
}

function testbus_claim_host {

	testbus_trace "claim host $*"

	__testbus_assert_handle $FUNCNAME
	if test -n "$TESTBUS_CLAIM_TIMEOUT"; then
		testbus_call claim-host --timeout $TESTBUS_CLAIM_TIMEOUT "$@" $TESTCASE_HANDLE
	else
		testbus_call claim-host "$@" $TESTCASE_HANDLE
	fi
}

function testbus_setenv {

	testbus_trace "setenv $*"

	__testbus_assert_handle $FUNCNAME
	testbus_call setenv $TESTCASE_HANDLE "$@"
}

function testbus_getenv {

	testbus_trace "getenv $*"

	case $1 in
	/org/opensuse/Testbus/*)
		context=$1; shift;;
	*)
		__testbus_assert_handle $FUNCNAME
		context=$TESTCASE_HANDLE;;
	esac

	testbus_call getenv $context "$@"
}

function testbus_getenv_nonempty {

	ret=`testbus_getenv "$@"`
	if [ -z "$ret" ]; then
		testbus_test_failure "Missing or empty environment variable ($@)"
		return 1
	fi

	echo "$ret"
	return 0;
}

function __testbus_upload_file {

	testbus_trace "upload file $*"
	testbus_call upload-file "$@"
}

function testbus_upload_file {

	testbus_trace "upload file $*"

	host=$1; shift
	testbus_call upload-file --host $host "$@"
}

function testbus_download_file {

	testbus_trace "download file $*"

	host=$1; shift
	testbus_call download-file --host $host "$@"
}

function testbus_download_eventlog {

	testbus_trace "download eventlog $*"

	host=$1; shift
	testbus_call get-events "$@" $host
}

function testbus_run_command {

	testbus_trace "run command $*"

	__testbus_assert_handle $FUNCNAME
	testbus_call run-command --context $TESTCASE_HANDLE "$@"
}

function __testbus_exit {

	if [ "$TESTBUS_FAILED_COUNT" -eq 0 ]; then
		echo "### SUMMARY: All tests completed successfully"
		exit 0
	else
		echo "### SUMMARY: $TESTBUS_FAILED_COUNT tests failed"
		echo "### SUMMARY: List of failed tests: ${TESTBUS_FAILED_LIST[@]}"
		exit 1
	fi >&2
}

function testbus_exit {

	trap "" 0 1 2

	testbus_finish_all_groups SUCCESS
	__testbus_exit
}

function testbus_exit_fail {

	trap "" 0 1 2

	if [ -n `__testbus_testcase_name` ]; then
		testbus_group_finish FAILED "$@"
		testbus_finish_all_groups FAILED
		__testbus_exit
	fi
}

function testbus_new_script {

	name=${1:-script}; shift

	if [ -z "$TESTCASE_TEMPDIR" ]; then
		echo "testbus_new_script called without a tempdir" >&2
		return 1
	fi

	script="$TESTCASE_TEMPDIR/$name"
	touch $script
	chmod 755 $script

	echo "$script"
}

function testbus_start_kvm {

	tag=$1; shift
	if [ -z "$tag" ]; then
		echo "testbus_start_kvm: no tag argument provided" >&2
		testbus_exit_fail
	fi

	image=$1; shift
	if [ -z "$image" ]; then
		echo "testbus_start_kvm: no image argument provided" >&2
		testbus_exit_fail
	fi

	mkdir -p /var/run/testbus/guestfs

	socket=/var/run/testbus-$tag.sock

	dbus-proxy \
		--identity "testbus-$tag" \
		--downstream unix-mux:$socket

	qemu-kvm \
		-name $tag \
		-pidfile /var/run/testbus/kvm-$tag.pid \
		-display vnc=:2 \
		-device virtio-serial \
		-device virtserialport,chardev=testbus-serial,name=org.opensuse.Testbus.0 \
		-chardev socket,id=testbus-serial,path=$socket \
		-virtfs local,path=/var/run/testbus/guestfs,security_model=passthrough,mount_tag=testbus \
		$image &
}



trap "testbus_exit_fail" 0 1 2
testbus_trace "Succesfully sourced testbus functions"
